h1. akka support

"akka":http://akkasource.org is a platform for building simple, correct, fault-tolerant, concurrent, and scalable applications for the JVM.  This module allows you to configure akka through The Play! framework's conf/application.conf file; it provides a few command-line scripts to start akka when your application starts; and it has some examples of it in action.

p(note). **Note on akka's REST and comet libraries** though the REST and comet jars are included in the distribution of this module, I discourage you from using them.  They are built to work with servlets, and probably will not do what you expect.  If you want to create RESTful web services, or use comet, I suggest you stick with the methods provided by Play! - using akka with Play! is easy, and mimicking the functionality provided by akka's REST and comet libraries is trivial.

p(note). Also, even though the Scala module is required, there is a Java API for akka.  I enjoy programming in Scala, and I have not looked much at the Java API, so the examples are all in Scala.  If you'd like to contribute some examples of the Java API, I'd be more than happy to include them!

**There are a couple of screencasts** 

"Screencast One for the akka module for The Play! framework":http://vimeo.com/10764693 

two

h2. Getting Started

p(note). It should be noted that both the Scala and akka modules require Play! 1.1, which is still under development, so until Play! 1.1 is final, use this at your own risk!  (it's more fun that way anyway!)

The Scala module is required, so if you have not installed it, you can with the **install** command.

bc. play install scala-head

Once that's done, go ahead and install the akka module

bc. play install akka

You can then create a new Play! project, called "myApp", with

bc. play new myApp --with scala,akka

Some default akka configuration will be appended to the end of your **conf/application.conf** file.  More information on that can be found below.

To include akka in an existing project add the following lines to your **conf/application.conf** file

bc. module.scala=${play.path}/modules/scala-head
module.akka=${play.path}/modules/akka

To **run** your application execute

bc. play akka:run 

(the above command will be changed to "play run" when a bug is fixed in the Play! 1.1 branch)

h2. Commands

All of these commands will be phased out when a bug is fixed in the 1.1 branch and they aren't needed any more.  Until then, use them instead of their counterparts

bc. play akka:run

bc. play akka:test

bc. play akka:start


h2. Configuration

When used outside of The Play! framework, akka is configured with an akka.conf file.  This plugin allows you to use the Play! **conf/application.conf** file to configure akka.  A default configuration is added to **conf/application.conf**.  "Detailed documentation":http://doc.akkasource.org/configuration on configuring akka can be found on the akka website, "http://akkasource.org":http://akkasource.org.  The traditional akka.conf (when used outside of Play!) file looks something like:

bc. <akka>
        version=0.8
        <actor>
            timeout=5000
            ...
        </actor>
        <stm>
            service=on
            ...
        </stm>
        ...
    </akka>
    
This configuration is expressed in the Play! **conf/application.conf** file by taking the node names and separating them with periods down to the property name and then separating that with an equals sign followed by the value, or more simply, the above becomes

bc. akka.version=0.8
akka.actor.timeout=5000
akka.stm.service=on

p(note). the akka.conf file contains a log section.  In this module, we append an "akka." to the "log", so in the akka.conf file, the following section

bc. <log>
    level=debug
    ...
</log>

becomes, in the **conf/application.conf**

bc. akka.log.level=debug


Here is an example of what you get when you create a new application with the **new** command

bc. akka.version=0.8.1
akka.actor.timeout=5000
akka.actor.serialize-messages=off
akka.stm.service=on
akka.stm.fair=on
akka.stm.max-nr-of-retries=1000
akka.stm.timeout = 10000
akka.remote.compression-scheme=zlib
akka.remote.zlib-compression-level=6
akka.remote.cluster.service=on
akka.remote.cluster.name=default
akka.remote.cluster.actor=se.scalablesolutions.akka.cluster.jgroups.JGroupsClusterActor
akka.remote.cluster.serializer=se.scalablesolutions.akka.serialization.Serializer$Java$
akka.remote.server.service=on
akka.remote.server.hostname=localhost
akka.remote.server.port=9999
akka.remote.server.connection-timeout=1000
akka.remote.client.reconnect-delay=5000
akka.remote.client.read-timeout=10000
akka.storage.cassandra.hostname=127.0.0.1
akka.storage.cassandra.port=9160
akka.storage.cassandra.consistency-level=QUORUM
akka.storage.mongodb.hostname=127.0.0.1
akka.storage.mongodb.port=27017
akka.storage.mongodb.dbname=mydb
akka.storage.redis.hostname=127.0.0.1
akka.storage.redis.port=6379
akka.log.filename=./logs/akka.log
akka.log.roll=daily
akka.log.level=debug
akka.log.console=on

h2. Examples

There are two examples included with the module, located in the sample-app folder.  To run the sample-app, make sure scala-head is installed, cd to the ${play.path}/modules/akka/sample-app directory and execute:

bc. play akka:run

The two examples are both hit counters that illustrate two different aspects of akka, and are both thoroughly explored in these two screencasts: "one":http://vimeo.com/10764693, two

The first example is in **app/controllers/HitCounter.scala**, and can be accessed at http://localhost:9000/hitCounter  It illustrates how to use Software Transactional Memory (STM).  Every time a user hits that URL, the hit counter will be increased.  Operations on the TransactionalRef must occur in the context of a transaction, which is atomic, isolated, and consistent, which basically means, if two requests try to update the reference at the same time, one will win and one will lose.  When the one that loses, loses, it will automatically retry the update, so if 20,000 people visit the site, the hit counter will accurately report 20,000.  This is thoroughly explored, along with implications, in the "screencast"http://vimeo.com/10764693.

The second example shows a hit counter that works in a clustered environment and is located in **app/controllers/ClusteredHitCounter.scala** along with **app/AkkaBootStrapJob.scala**.  The previous example will accurately report hits in a single server environment, but when multiple servers are clustered together, the number will report how many users have hit a given server, not the cluster as a whole.  To accurately tally the number of hits on a cluster as a whole, a server managed actor is registered to keep track of hits and report them when asked.  This example is a little more involved because to see it in action, multiple servers need to be started - it's fully explored in the screencast.